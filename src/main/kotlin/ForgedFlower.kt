import fudge.forgedflower.api.IFabricJavadocProvider
import fudge.forgedflower.main.DecompilerContext
import fudge.forgedflower.main.Fernflower
import fudge.forgedflower.main.extern.IBytecodeProvider
import fudge.forgedflower.main.extern.IFernflowerLogger
import fudge.forgedflower.main.extern.IFernflowerPreferences.*
import fudge.forgedflower.main.extern.IResultSaver
import fudge.forgedflower.util.InterpreterUtil
import net.fabricmc.loom.decompilers.fernflower.FernFlowerUtils
import net.fabricmc.loom.decompilers.fernflower.ThreadIDFFLogger
import net.fabricmc.loom.util.LineNumberRemapper
import net.fabricmc.loom.util.progress.ProgressLogger
import java.nio.file.Path
import java.util.jar.Manifest

object ForgedFlower {
    //TODO: make sure this works, then expand
    data class Preferences(
        val removeBridge: Boolean = true,
        val removeSynthetic: Boolean = true,
        val decompileInnerClasses: Boolean = true,
        val collapseJava4ClassReferences: Boolean = true,
        val decompileAssertions: Boolean = true,
        val hideEmptySuperCall: Boolean = true,
        val hideDefaultConstructor: Boolean = true,
        val decompileGenericSignatures: Boolean = true,
        val assumeReturnNotThrowingException: Boolean = true,
        /** special case: search for 'synchronized' ranges w/o monitorexit instruction (as generated by Kotlin and Scala) */
        val ensureSynchronizedMonitor: Boolean = true,
        val decompileEnums: Boolean = true,
        /**
         * remove getClass() invocation, when it is part of a qualified new statement
         */
        val removeGetClassOfNew: Boolean = true,
        val outputLiteralsAsIs: Boolean = false,
        val asciiStringCharacters: Boolean = false,
        val interpret1AsBooleanTrue: Boolean = true,
        val allowUnsetSyntheticAttribute: Boolean = false,
        val interpretNamelessTypeAsObject: Boolean = true,
        val reconstructVariableNamesFromDebugInfo: Boolean = true,
        val useMethodParameterNames: Boolean = true,
        val removeEmptyExceptionRanges: Boolean = true,
        val deInlineFinallyStructures: Boolean = true,
        val renameAmbiguousClasses: Boolean = false,
        val removeInsertedNotNullCode: Boolean = true,
        val decompileLambdasToAnonClasses: Boolean = false,
        val bytecodeSourceMapping: Boolean = true,
        val ignoreInvalidBytecode: Boolean = false,
        val verifyAnonymousClasses: Boolean = false,
        val includeEntireClasspath: Boolean = false,
        val explicitGenericArguments: Boolean = false,
        val inlineSimpleLambdas: Boolean = true,
        val threads: Int = Runtime.getRuntime().availableProcessors(),
        val logLevel: String = "trace",
        val maximumProcessingTimePerMethod: Int = 0,
        val renameEntities: Boolean = false,
        val identifierRenamerClass: String? = null,
        val useLinuxNewLine: Boolean = !InterpreterUtil.IS_WINDOWS,
        val indentString: String = "    ",
        /**
         * Copyright notice, etc
         */
        val banner: String = "",
        val dumpOriginalLines: Boolean = false,
        val unitTestMode: Boolean = false,
        val useJadVariableNaming: Boolean = false,
        val skipExtraFiles: Boolean = false
    )

    private fun Preferences.toForgedFlowerMap() = mapOf(
        REMOVE_BRIDGE to removeBridge,
        REMOVE_SYNTHETIC to removeSynthetic,
        DECOMPILE_INNER to decompileInnerClasses,
        DECOMPILE_CLASS_1_4 to collapseJava4ClassReferences,
        DECOMPILE_ASSERTIONS to decompileAssertions,
        HIDE_EMPTY_SUPER to hideEmptySuperCall,
        HIDE_DEFAULT_CONSTRUCTOR to hideDefaultConstructor,
        DECOMPILE_GENERIC_SIGNATURES to decompileGenericSignatures,
        NO_EXCEPTIONS_RETURN to assumeReturnNotThrowingException,
        ENSURE_SYNCHRONIZED_MONITOR to ensureSynchronizedMonitor,
        DECOMPILE_ENUM to decompileEnums,
        REMOVE_GET_CLASS_NEW to removeGetClassOfNew,
        LITERALS_AS_IS to outputLiteralsAsIs,
        BOOLEAN_TRUE_ONE to interpret1AsBooleanTrue,
        ASCII_STRING_CHARACTERS to asciiStringCharacters,
        SYNTHETIC_NOT_SET to allowUnsetSyntheticAttribute,
        UNDEFINED_PARAM_TYPE_OBJECT to interpretNamelessTypeAsObject,
        USE_DEBUG_VAR_NAMES to reconstructVariableNamesFromDebugInfo,
        USE_METHOD_PARAMETERS to useMethodParameterNames,
        REMOVE_EMPTY_RANGES to removeEmptyExceptionRanges,
        FINALLY_DEINLINE to deInlineFinallyStructures,
        IDEA_NOT_NULL_ANNOTATION to removeInsertedNotNullCode,
        LAMBDA_TO_ANONYMOUS_CLASS to decompileLambdasToAnonClasses,
        BYTECODE_SOURCE_MAPPING to bytecodeSourceMapping,
        IGNORE_INVALID_BYTECODE to ignoreInvalidBytecode,
        VERIFY_ANONYMOUS_CLASSES to verifyAnonymousClasses,
        INCLUDE_ENTIRE_CLASSPATH to includeEntireClasspath,
        EXPLICIT_GENERIC_ARGUMENTS to explicitGenericArguments,
        INLINE_SIMPLE_LAMBDAS to inlineSimpleLambdas,
        THREADS to threads,
        LOG_LEVEL to logLevel,
        MAX_PROCESSING_METHOD to maximumProcessingTimePerMethod,
        RENAME_ENTITIES to renameEntities,
        USER_RENAMER_CLASS to identifierRenamerClass,
        NEW_LINE_SEPARATOR to useLinuxNewLine,
        INDENT_STRING to indentString,
        BANNER to banner,
        DUMP_ORIGINAL_LINES to dumpOriginalLines,
        UNIT_TEST_MODE to unitTestMode,
        USE_JAD_VARNAMING to useJadVariableNaming,
        SKIP_EXTRA_FILES to skipExtraFiles
    ).toForgedFlowerAcceptable()

    private fun Map<String, Any?>.toForgedFlowerAcceptable(): Map<String, String> =
        filterValues { it != null }.mapValues { (_, v) ->
            when (v) {
                is String -> v
                is Int -> v.toString()
                is Boolean -> if (v) "1" else "0"
                else -> error("Unexpected preference type of '$v': ${v!!::class.qualifiedName}")
            }
        }

    fun decompile(
        preferences: Preferences,
        libraries: List<Path>,
        javaDocs: Path,
        input: Path,
        output: Path,
        lineMap: Path
    ) {
        val optionsWithJavadoc = preferences.toForgedFlowerMap() +
                (IFabricJavadocProvider.PROPERTY_NAME to ForgedFlowerTinyJavadocProvider(javaDocs.toFile()))

        val saver = net.fabricmc.loom.decompilers.fernflower.ThreadSafeResultSaver(
            { output.toFile() }, { lineMap.toFile() }
        )
        val logger = ThreadIDFFLogger()
        val ff = Fernflower(
            IBytecodeProvider { ext, int -> FernFlowerUtils.getBytecode(ext, int) },
            ForgedFlowerThreadSafeResultSaver(saver), optionsWithJavadoc,
            ForgedFlowerThreadIDFFLogger(logger), preferences.threads
        )

        for (library in libraries) {
            ff.addLibrary(library.toFile())
        }

        ff.addSource(input.toFile())
        ff.decompileContext()

    }
//
//    fun addLineNumbersFromDecompilation(lineMap: Path, ){
//        val remapper = LineNumberRemapper()
//        remapper.readMappings(linemap.toFile())
//
//        val progressLogger =
//            ProgressLogger.getProgressFactory(getProject(), javaClass.name)
//        progressLogger.start("Adjusting line numbers", "linemap")
//
//        StitchUtil.getJarFileSystem(oldCompiledJar.toFile(), true).use({ inFs ->
//            StitchUtil.getJarFileSystem(linemappedJarDestination.toFile(), true)
//                .use({ outFs -> remapper.process(progressLogger, inFs.get().getPath("/"), outFs.get().getPath("/")) })
//        })
//
//        progressLogger.completed()
//    }
}

/**
 * The fabric ThreadSafeResultSaver implements FabricFlower's IResultSaver, and not ForgedFlower's,
 * so we need to convert between the two.
 */
private class ForgedFlowerThreadSafeResultSaver(private val fabricSaver: net.fabricmc.loom.decompilers.fernflower.ThreadSafeResultSaver) :
    IResultSaver {
    override fun saveFolder(p0: String?) = fabricSaver.saveFolder(p0)
    override fun closeArchive(p0: String?, p1: String?) = fabricSaver.closeArchive(p0, p1)
    override fun copyFile(p0: String?, p1: String?, p2: String?) = fabricSaver.copyFile(p0, p1, p2)
    override fun copyEntry(p0: String?, p1: String?, p2: String?, p3: String?) = fabricSaver.copyEntry(p0, p1, p2, p3)
    override fun saveClassEntry(
        path: String?,
        archiveName: String?,
        qualifiedName: String?,
        entryName: String?,
        content: String?
    ) {
        val mapping =
            if (qualifiedName != null && DecompilerContext.getOption(BYTECODE_SOURCE_MAPPING)) {
                DecompilerContext.getBytecodeSourceMapper().originalLinesMapping
            } else null

        fabricSaver.saveClassEntry(path, archiveName, qualifiedName, entryName, content, mapping)
    }


    override fun createArchive(p0: String?, p1: String?, p2: Manifest?) = fabricSaver.createArchive(p0, p1, p2)
    override fun saveClassFile(p0: String?, p1: String?, p2: String?, p3: String?, p4: IntArray?) =
        fabricSaver.saveClassFile(p0, p1, p2, p3, p4)

    override fun saveDirEntry(p0: String?, p1: String?, p2: String?) = fabricSaver.saveDirEntry(p0, p1, p2)


}

private typealias ForgedSeverity = fudge.forgedflower.main.extern.IFernflowerLogger.Severity
private typealias FabricSeverity = org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity

private val ForgedSeverity.fabric: FabricSeverity
    get() = when (this) {
        ForgedSeverity.TRACE -> FabricSeverity.TRACE
        ForgedSeverity.INFO -> FabricSeverity.INFO
        ForgedSeverity.WARN -> FabricSeverity.WARN
        ForgedSeverity.ERROR -> FabricSeverity.ERROR
    }

/**
 * Same thing
 */
private class ForgedFlowerThreadIDFFLogger(private val fabricLogger: ThreadIDFFLogger) : IFernflowerLogger() {
    override fun writeMessage(p0: String?, p1: Severity) = fabricLogger.writeMessage(p0, p1.fabric)
    override fun writeMessage(p0: String?, p1: Severity, p2: Throwable?) = fabricLogger.writeMessage(p0, p1.fabric, p2)
    override fun writeMessage(message: String?, t: Throwable?) = fabricLogger.writeMessage(message, t)
    override fun startWriteClass(className: String?) = fabricLogger.startWriteClass(className)
    override fun setSeverity(severity: Severity) = fabricLogger.setSeverity(severity.fabric)
    override fun endClass() = fabricLogger.endClass()
    override fun endMethod() = fabricLogger.endMethod()
    override fun startMethod(methodName: String?) = fabricLogger.startMethod(methodName)
    override fun endWriteClass() = fabricLogger.endWriteClass()
    override fun startClass(className: String?) = fabricLogger.startClass(className)
    override fun startReadingClass(className: String?) = fabricLogger.startReadingClass(className)
    override fun accepts(severity: Severity): Boolean = fabricLogger.accepts(severity.fabric)
    override fun endReadingClass() = fabricLogger.endReadingClass()
}
